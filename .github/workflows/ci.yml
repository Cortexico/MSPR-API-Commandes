# name: CI/CD Pipeline for FastAPI

# on:
#   push:
#     branches: [ main ]
#   pull_request:
#     branches: [ main ]

# jobs:
#   build-and-test:
#     runs-on: ubuntu-latest

#     services:
#       postgres:
#         image: postgres:13
#         env:
#           POSTGRES_USER: orders
#           POSTGRES_PASSWORD: apiOrders
#           POSTGRES_DB: orders_db
#         options: >-
#           --health-cmd pg_isready
#           --health-interval 10s
#           --health-timeout 5s
#           --health-retries 5
#         ports:
#           - 5432:5432

#     steps:
#     - uses: actions/checkout@v2
#       # Cette étape récupère le code source de la branche actuelle

#     - name: Set up Python 3.9
#       uses: actions/setup-python@v2
#       with:
#         python-version: '3.9'
#       # Configure Python 3.9 pour l'utilisation dans les étapes suivantes

#     - name: Set PYTHONPATH
#       run: echo "PYTHONPATH=$GITHUB_WORKSPACE" >> $GITHUB_ENV
#       # Définit la variable PYTHONPATH pour s'assurer que Python trouve les modules

#     - name: Install dependencies
#       run: |
#         python -m pip install --upgrade pip
#         pip install -r requirements.txt
#       # Installe les dépendances requises à partir de requirements.txt

#     - name: Configure environment variables for testing
#       run: |
#         echo "POSTGRES_USER=orders" >> $GITHUB_ENV
#         echo "POSTGRES_PASSWORD=apiOrders" >> $GITHUB_ENV
#         echo "POSTGRES_DB=orders_db" >> $GITHUB_ENV
#         echo "POSTGRES_PORT=5432" >> $GITHUB_ENV  # Ajoutez cette ligne
#         echo "DATABASE_URL=postgresql+asyncpg://orders:apiOrders@postgres:5432/orders_db" >> $GITHUB_ENV
#       # Configure les variables d'environnement nécessaires pour les tests

#     - name: Run tests
#       run: |
#         pytest tests/
#       # Exécute les tests unitaires et d'intégration

#     - name: Build Docker image
#       run: |
#         docker build -t myapi .
#       # Construit une image Docker pour l'application

name: CI/CD Pipeline for Commandes Api

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: orders
          POSTGRES_PASSWORD: apiOrders
          POSTGRES_DB: orders_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      # Configure PostgreSQL service avec des checks de santé pour s'assurer que la DB est prête avant de lancer les tests.

    steps:
    - uses: actions/checkout@v2
      # Récupère le code source de la branche actuelle.

    - name: Set up Python 3.9
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
      # Configure Python 3.9 pour l'utilisation dans les étapes suivantes.

    - name: Cache Python packages
      uses: actions/cache@v2
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
      # Met en cache les dépendances Python pour accélérer l'installation des dépendances lors des builds suivants.

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      # Installe les dépendances requises à partir de requirements.txt.

    - name: Configure environment variables for testing
      run: |
        echo "DATABASE_URL=postgresql+asyncpg://orders:apiOrders@localhost:5432/orders_db" >> $GITHUB_ENV
      # Configure l'URL de la base de données pour les tests, s'assurant que les tests utilisent la bonne instance de PostgreSQL.

    - name: Run tests
      run: |
        pytest tests/
      # Exécute les tests unitaires et d'intégration.

    - name: Build Docker image
      run: |
        docker build -t myapi .
      # Construit une image Docker pour l'application.

    - name: Notify on Slack
      if: always()  # Exécute cette étape quel que soit le résultat des étapes précédentes.
      uses: rtCamp/action-slack-notify@v2
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        SLACK_CHANNEL: your-slack-channel-name
        SLACK_TITLE: 'CI/CD Pipeline Execution Result'
        SLACK_MESSAGE: '${{ job.status }}: Your CI/CD pipeline execution is complete.'
        SLACK_COLOR: ${{ job.status == 'success' ? 'good' : 'danger' }}
      # Envoie une notification Slack avec le résultat de l'exécution du pipeline. Remplacez 'your-slack-channel-name' par le nom de votre canal Slack.


